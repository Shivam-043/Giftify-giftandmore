"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const jwt_1 = require("@vonage/jwt");
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const types_1 = require("./types");
class Auth {
    constructor(opts) {
        this.getQueryParams = (params) => {
            return Object.assign({ api_key: this.apiKey, api_secret: this.apiSecret }, params);
        };
        this.createBasicHeader = () => {
            const buf = Buffer.from(`${this.apiKey}:${this.apiSecret}`);
            return 'Basic ' + buf.toString('base64');
        };
        this.createBearerHeader = () => {
            return 'Bearer ' + (0, jwt_1.tokenGenerate)(this.applicationId, this.privateKey);
        };
        this.createSignatureHash = (params) => {
            const returnParams = Object.assign({ api_key: this.apiKey }, params);
            returnParams.timestamp = Math.floor(Date.now() / 1000).toString();
            const keys = Object.keys(returnParams);
            const stringifiedParamsforSigning = keys
                .sort()
                .map((keyName) => {
                return `&${keyName}=${returnParams[keyName]
                    .toString()
                    .replace(/(&|=)/gi, '_')}`;
            }, [])
                .join('');
            if (this.signature.algorithm === types_1.AlgorithmTypes.md5hash) {
                returnParams.sig = (0, crypto_1.createHash)('md5')
                    .update(stringifiedParamsforSigning + this.signature.secret)
                    .digest('hex');
            }
            if (this.signature.algorithm === types_1.AlgorithmTypes.md5hmac) {
                returnParams.sig = (0, crypto_1.createHmac)('md5', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
            }
            if (this.signature.algorithm === types_1.AlgorithmTypes.sha1hmac) {
                returnParams.sig = (0, crypto_1.createHmac)('sha1', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
            }
            if (this.signature.algorithm === types_1.AlgorithmTypes.sha256hmac) {
                returnParams.sig = (0, crypto_1.createHmac)('sha256', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
            }
            if (this.signature.algorithm === types_1.AlgorithmTypes.sha512hmac) {
                returnParams.sig = (0, crypto_1.createHmac)('sha512', this.signature.secret)
                    .update(stringifiedParamsforSigning)
                    .digest('hex');
            }
            return returnParams;
        };
        this.apiKey = (opts === null || opts === void 0 ? void 0 : opts.apiKey) || '';
        this.apiSecret = (opts === null || opts === void 0 ? void 0 : opts.apiSecret) || '';
        this.signature = (opts === null || opts === void 0 ? void 0 : opts.signature) || null;
        this.applicationId = (opts === null || opts === void 0 ? void 0 : opts.applicationId) || null;
        if (opts === null || opts === void 0 ? void 0 : opts.privateKey) {
            if ((0, fs_1.existsSync)(opts.privateKey)) {
                opts.privateKey = (0, fs_1.readFileSync)(opts.privateKey).toString();
            }
            if (opts.privateKey instanceof Buffer) {
                this.privateKey = opts.privateKey.toString();
            }
            else {
                this.privateKey = opts.privateKey;
            }
        }
    }
}
exports.Auth = Auth;
//# sourceMappingURL=auth.js.map